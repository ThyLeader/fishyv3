// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: fishy.proto

package pb

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import context "golang.org/x/net/context"
import grpc "google.golang.org/grpc"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type FishCategory int32

const (
	FishCategory_FISH      FishCategory = 0
	FishCategory_LEGENDARY FishCategory = 1
	FishCategory_GARBAGE   FishCategory = 2
	FishCategory_ALL       FishCategory = 3
)

var FishCategory_name = map[int32]string{
	0: "FISH",
	1: "LEGENDARY",
	2: "GARBAGE",
	3: "ALL",
}
var FishCategory_value = map[string]int32{
	"FISH":      0,
	"LEGENDARY": 1,
	"GARBAGE":   2,
	"ALL":       3,
}

func (x FishCategory) String() string {
	return proto.EnumName(FishCategory_name, int32(x))
}
func (FishCategory) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_fishy_b39c152d67c83cbd, []int{0}
}

type Item int32

const (
	Item_BAIT    Item = 0
	Item_ROD     Item = 1
	Item_HOOK    Item = 2
	Item_VEHICLE Item = 3
	Item_BAITBOX Item = 4
)

var Item_name = map[int32]string{
	0: "BAIT",
	1: "ROD",
	2: "HOOK",
	3: "VEHICLE",
	4: "BAITBOX",
}
var Item_value = map[string]int32{
	"BAIT":    0,
	"ROD":     1,
	"HOOK":    2,
	"VEHICLE": 3,
	"BAITBOX": 4,
}

func (x Item) String() string {
	return proto.EnumName(Item_name, int32(x))
}
func (Item) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_fishy_b39c152d67c83cbd, []int{1}
}

type Location int32

const (
	Location_LAKE  Location = 0
	Location_RIVER Location = 1
	Location_OCEAN Location = 2
)

var Location_name = map[int32]string{
	0: "LAKE",
	1: "RIVER",
	2: "OCEAN",
}
var Location_value = map[string]int32{
	"LAKE":  0,
	"RIVER": 1,
	"OCEAN": 2,
}

func (x Location) String() string {
	return proto.EnumName(Location_name, int32(x))
}
func (Location) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_fishy_b39c152d67c83cbd, []int{2}
}

type BaitTier int32

const (
	BaitTier_T1 BaitTier = 0
	BaitTier_T2 BaitTier = 1
	BaitTier_T3 BaitTier = 2
	BaitTier_T4 BaitTier = 3
	BaitTier_T5 BaitTier = 4
)

var BaitTier_name = map[int32]string{
	0: "T1",
	1: "T2",
	2: "T3",
	3: "T4",
	4: "T5",
}
var BaitTier_value = map[string]int32{
	"T1": 0,
	"T2": 1,
	"T3": 2,
	"T4": 3,
	"T5": 4,
}

func (x BaitTier) String() string {
	return proto.EnumName(BaitTier_name, int32(x))
}
func (BaitTier) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_fishy_b39c152d67c83cbd, []int{3}
}

type InventoryRequest struct {
	User                 string   `protobuf:"bytes,1,opt,name=user,proto3" json:"user,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InventoryRequest) Reset()         { *m = InventoryRequest{} }
func (m *InventoryRequest) String() string { return proto.CompactTextString(m) }
func (*InventoryRequest) ProtoMessage()    {}
func (*InventoryRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_fishy_b39c152d67c83cbd, []int{0}
}
func (m *InventoryRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InventoryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InventoryRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *InventoryRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InventoryRequest.Merge(dst, src)
}
func (m *InventoryRequest) XXX_Size() int {
	return m.Size()
}
func (m *InventoryRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_InventoryRequest.DiscardUnknown(m)
}

var xxx_messageInfo_InventoryRequest proto.InternalMessageInfo

func (m *InventoryRequest) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

type InventoryResponse struct {
	Items                *UserItems     `protobuf:"bytes,1,opt,name=items" json:"items,omitempty"`
	Fish                 *FishInventory `protobuf:"bytes,2,opt,name=fish" json:"fish,omitempty"`
	MaxFish              int32          `protobuf:"varint,3,opt,name=max_fish,json=maxFish,proto3" json:"max_fish,omitempty"`
	MaxBait              int32          `protobuf:"varint,4,opt,name=max_bait,json=maxBait,proto3" json:"max_bait,omitempty"`
	UserTier             int32          `protobuf:"varint,5,opt,name=user_tier,json=userTier,proto3" json:"user_tier,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *InventoryResponse) Reset()         { *m = InventoryResponse{} }
func (m *InventoryResponse) String() string { return proto.CompactTextString(m) }
func (*InventoryResponse) ProtoMessage()    {}
func (*InventoryResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_fishy_b39c152d67c83cbd, []int{1}
}
func (m *InventoryResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InventoryResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InventoryResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *InventoryResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InventoryResponse.Merge(dst, src)
}
func (m *InventoryResponse) XXX_Size() int {
	return m.Size()
}
func (m *InventoryResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_InventoryResponse.DiscardUnknown(m)
}

var xxx_messageInfo_InventoryResponse proto.InternalMessageInfo

func (m *InventoryResponse) GetItems() *UserItems {
	if m != nil {
		return m.Items
	}
	return nil
}

func (m *InventoryResponse) GetFish() *FishInventory {
	if m != nil {
		return m.Fish
	}
	return nil
}

func (m *InventoryResponse) GetMaxFish() int32 {
	if m != nil {
		return m.MaxFish
	}
	return 0
}

func (m *InventoryResponse) GetMaxBait() int32 {
	if m != nil {
		return m.MaxBait
	}
	return 0
}

func (m *InventoryResponse) GetUserTier() int32 {
	if m != nil {
		return m.UserTier
	}
	return 0
}

type GetLocationRequest struct {
	User                 string   `protobuf:"bytes,1,opt,name=user,proto3" json:"user,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetLocationRequest) Reset()         { *m = GetLocationRequest{} }
func (m *GetLocationRequest) String() string { return proto.CompactTextString(m) }
func (*GetLocationRequest) ProtoMessage()    {}
func (*GetLocationRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_fishy_b39c152d67c83cbd, []int{2}
}
func (m *GetLocationRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetLocationRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetLocationRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetLocationRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetLocationRequest.Merge(dst, src)
}
func (m *GetLocationRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetLocationRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetLocationRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetLocationRequest proto.InternalMessageInfo

func (m *GetLocationRequest) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

type GetLocationResponse struct {
	Location             Location `protobuf:"varint,1,opt,name=location,proto3,enum=fishyv3.Location" json:"location,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetLocationResponse) Reset()         { *m = GetLocationResponse{} }
func (m *GetLocationResponse) String() string { return proto.CompactTextString(m) }
func (*GetLocationResponse) ProtoMessage()    {}
func (*GetLocationResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_fishy_b39c152d67c83cbd, []int{3}
}
func (m *GetLocationResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetLocationResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetLocationResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetLocationResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetLocationResponse.Merge(dst, src)
}
func (m *GetLocationResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetLocationResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetLocationResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetLocationResponse proto.InternalMessageInfo

func (m *GetLocationResponse) GetLocation() Location {
	if m != nil {
		return m.Location
	}
	return Location_LAKE
}

type SetLocationRequest struct {
	User                 string   `protobuf:"bytes,1,opt,name=user,proto3" json:"user,omitempty"`
	Location             Location `protobuf:"varint,2,opt,name=location,proto3,enum=fishyv3.Location" json:"location,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SetLocationRequest) Reset()         { *m = SetLocationRequest{} }
func (m *SetLocationRequest) String() string { return proto.CompactTextString(m) }
func (*SetLocationRequest) ProtoMessage()    {}
func (*SetLocationRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_fishy_b39c152d67c83cbd, []int{4}
}
func (m *SetLocationRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetLocationRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetLocationRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SetLocationRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetLocationRequest.Merge(dst, src)
}
func (m *SetLocationRequest) XXX_Size() int {
	return m.Size()
}
func (m *SetLocationRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SetLocationRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SetLocationRequest proto.InternalMessageInfo

func (m *SetLocationRequest) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

func (m *SetLocationRequest) GetLocation() Location {
	if m != nil {
		return m.Location
	}
	return Location_LAKE
}

type SetLocationResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SetLocationResponse) Reset()         { *m = SetLocationResponse{} }
func (m *SetLocationResponse) String() string { return proto.CompactTextString(m) }
func (*SetLocationResponse) ProtoMessage()    {}
func (*SetLocationResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_fishy_b39c152d67c83cbd, []int{5}
}
func (m *SetLocationResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetLocationResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetLocationResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SetLocationResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetLocationResponse.Merge(dst, src)
}
func (m *SetLocationResponse) XXX_Size() int {
	return m.Size()
}
func (m *SetLocationResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SetLocationResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SetLocationResponse proto.InternalMessageInfo

type BuyItemRequest struct {
	Item                 Item     `protobuf:"varint,1,opt,name=item,proto3,enum=fishyv3.Item" json:"item,omitempty"`
	Tier                 int32    `protobuf:"varint,2,opt,name=tier,proto3" json:"tier,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BuyItemRequest) Reset()         { *m = BuyItemRequest{} }
func (m *BuyItemRequest) String() string { return proto.CompactTextString(m) }
func (*BuyItemRequest) ProtoMessage()    {}
func (*BuyItemRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_fishy_b39c152d67c83cbd, []int{6}
}
func (m *BuyItemRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BuyItemRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BuyItemRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *BuyItemRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BuyItemRequest.Merge(dst, src)
}
func (m *BuyItemRequest) XXX_Size() int {
	return m.Size()
}
func (m *BuyItemRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BuyItemRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BuyItemRequest proto.InternalMessageInfo

func (m *BuyItemRequest) GetItem() Item {
	if m != nil {
		return m.Item
	}
	return Item_BAIT
}

func (m *BuyItemRequest) GetTier() int32 {
	if m != nil {
		return m.Tier
	}
	return 0
}

type BuyItemResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BuyItemResponse) Reset()         { *m = BuyItemResponse{} }
func (m *BuyItemResponse) String() string { return proto.CompactTextString(m) }
func (*BuyItemResponse) ProtoMessage()    {}
func (*BuyItemResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_fishy_b39c152d67c83cbd, []int{7}
}
func (m *BuyItemResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BuyItemResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BuyItemResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *BuyItemResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BuyItemResponse.Merge(dst, src)
}
func (m *BuyItemResponse) XXX_Size() int {
	return m.Size()
}
func (m *BuyItemResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BuyItemResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BuyItemResponse proto.InternalMessageInfo

type BlacklistRequest struct {
	User                 string   `protobuf:"bytes,1,opt,name=user,proto3" json:"user,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BlacklistRequest) Reset()         { *m = BlacklistRequest{} }
func (m *BlacklistRequest) String() string { return proto.CompactTextString(m) }
func (*BlacklistRequest) ProtoMessage()    {}
func (*BlacklistRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_fishy_b39c152d67c83cbd, []int{8}
}
func (m *BlacklistRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlacklistRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlacklistRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *BlacklistRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlacklistRequest.Merge(dst, src)
}
func (m *BlacklistRequest) XXX_Size() int {
	return m.Size()
}
func (m *BlacklistRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BlacklistRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BlacklistRequest proto.InternalMessageInfo

func (m *BlacklistRequest) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

type BlacklistResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BlacklistResponse) Reset()         { *m = BlacklistResponse{} }
func (m *BlacklistResponse) String() string { return proto.CompactTextString(m) }
func (*BlacklistResponse) ProtoMessage()    {}
func (*BlacklistResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_fishy_b39c152d67c83cbd, []int{9}
}
func (m *BlacklistResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlacklistResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlacklistResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *BlacklistResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlacklistResponse.Merge(dst, src)
}
func (m *BlacklistResponse) XXX_Size() int {
	return m.Size()
}
func (m *BlacklistResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BlacklistResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BlacklistResponse proto.InternalMessageInfo

type UnblacklistRequest struct {
	User                 string   `protobuf:"bytes,1,opt,name=user,proto3" json:"user,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UnblacklistRequest) Reset()         { *m = UnblacklistRequest{} }
func (m *UnblacklistRequest) String() string { return proto.CompactTextString(m) }
func (*UnblacklistRequest) ProtoMessage()    {}
func (*UnblacklistRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_fishy_b39c152d67c83cbd, []int{10}
}
func (m *UnblacklistRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnblacklistRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnblacklistRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *UnblacklistRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnblacklistRequest.Merge(dst, src)
}
func (m *UnblacklistRequest) XXX_Size() int {
	return m.Size()
}
func (m *UnblacklistRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UnblacklistRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UnblacklistRequest proto.InternalMessageInfo

func (m *UnblacklistRequest) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

type UnblacklistResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UnblacklistResponse) Reset()         { *m = UnblacklistResponse{} }
func (m *UnblacklistResponse) String() string { return proto.CompactTextString(m) }
func (*UnblacklistResponse) ProtoMessage()    {}
func (*UnblacklistResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_fishy_b39c152d67c83cbd, []int{11}
}
func (m *UnblacklistResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnblacklistResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnblacklistResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *UnblacklistResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnblacklistResponse.Merge(dst, src)
}
func (m *UnblacklistResponse) XXX_Size() int {
	return m.Size()
}
func (m *UnblacklistResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UnblacklistResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UnblacklistResponse proto.InternalMessageInfo

type StartGatherBaitRequest struct {
	User                 string   `protobuf:"bytes,1,opt,name=user,proto3" json:"user,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StartGatherBaitRequest) Reset()         { *m = StartGatherBaitRequest{} }
func (m *StartGatherBaitRequest) String() string { return proto.CompactTextString(m) }
func (*StartGatherBaitRequest) ProtoMessage()    {}
func (*StartGatherBaitRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_fishy_b39c152d67c83cbd, []int{12}
}
func (m *StartGatherBaitRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StartGatherBaitRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StartGatherBaitRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *StartGatherBaitRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StartGatherBaitRequest.Merge(dst, src)
}
func (m *StartGatherBaitRequest) XXX_Size() int {
	return m.Size()
}
func (m *StartGatherBaitRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StartGatherBaitRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StartGatherBaitRequest proto.InternalMessageInfo

func (m *StartGatherBaitRequest) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

type StartGatherBaitResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StartGatherBaitResponse) Reset()         { *m = StartGatherBaitResponse{} }
func (m *StartGatherBaitResponse) String() string { return proto.CompactTextString(m) }
func (*StartGatherBaitResponse) ProtoMessage()    {}
func (*StartGatherBaitResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_fishy_b39c152d67c83cbd, []int{13}
}
func (m *StartGatherBaitResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StartGatherBaitResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StartGatherBaitResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *StartGatherBaitResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StartGatherBaitResponse.Merge(dst, src)
}
func (m *StartGatherBaitResponse) XXX_Size() int {
	return m.Size()
}
func (m *StartGatherBaitResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_StartGatherBaitResponse.DiscardUnknown(m)
}

var xxx_messageInfo_StartGatherBaitResponse proto.InternalMessageInfo

type CheckGatherBaitRequest struct {
	User                 string   `protobuf:"bytes,1,opt,name=user,proto3" json:"user,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CheckGatherBaitRequest) Reset()         { *m = CheckGatherBaitRequest{} }
func (m *CheckGatherBaitRequest) String() string { return proto.CompactTextString(m) }
func (*CheckGatherBaitRequest) ProtoMessage()    {}
func (*CheckGatherBaitRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_fishy_b39c152d67c83cbd, []int{14}
}
func (m *CheckGatherBaitRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckGatherBaitRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CheckGatherBaitRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CheckGatherBaitRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckGatherBaitRequest.Merge(dst, src)
}
func (m *CheckGatherBaitRequest) XXX_Size() int {
	return m.Size()
}
func (m *CheckGatherBaitRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckGatherBaitRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CheckGatherBaitRequest proto.InternalMessageInfo

func (m *CheckGatherBaitRequest) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

type CheckGatherBaitResponse struct {
	Remaining            int32    `protobuf:"varint,1,opt,name=remaining,proto3" json:"remaining,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CheckGatherBaitResponse) Reset()         { *m = CheckGatherBaitResponse{} }
func (m *CheckGatherBaitResponse) String() string { return proto.CompactTextString(m) }
func (*CheckGatherBaitResponse) ProtoMessage()    {}
func (*CheckGatherBaitResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_fishy_b39c152d67c83cbd, []int{15}
}
func (m *CheckGatherBaitResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckGatherBaitResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CheckGatherBaitResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CheckGatherBaitResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckGatherBaitResponse.Merge(dst, src)
}
func (m *CheckGatherBaitResponse) XXX_Size() int {
	return m.Size()
}
func (m *CheckGatherBaitResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckGatherBaitResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CheckGatherBaitResponse proto.InternalMessageInfo

func (m *CheckGatherBaitResponse) GetRemaining() int32 {
	if m != nil {
		return m.Remaining
	}
	return 0
}

type LeaderboardRequest struct {
	Global               bool     `protobuf:"varint,1,opt,name=global,proto3" json:"global,omitempty"`
	Page                 int32    `protobuf:"varint,2,opt,name=page,proto3" json:"page,omitempty"`
	User                 string   `protobuf:"bytes,3,opt,name=user,proto3" json:"user,omitempty"`
	Guild                string   `protobuf:"bytes,4,opt,name=guild,proto3" json:"guild,omitempty"`
	GuildName            string   `protobuf:"bytes,5,opt,name=guild_name,json=guildName,proto3" json:"guild_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LeaderboardRequest) Reset()         { *m = LeaderboardRequest{} }
func (m *LeaderboardRequest) String() string { return proto.CompactTextString(m) }
func (*LeaderboardRequest) ProtoMessage()    {}
func (*LeaderboardRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_fishy_b39c152d67c83cbd, []int{16}
}
func (m *LeaderboardRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LeaderboardRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LeaderboardRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *LeaderboardRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LeaderboardRequest.Merge(dst, src)
}
func (m *LeaderboardRequest) XXX_Size() int {
	return m.Size()
}
func (m *LeaderboardRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LeaderboardRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LeaderboardRequest proto.InternalMessageInfo

func (m *LeaderboardRequest) GetGlobal() bool {
	if m != nil {
		return m.Global
	}
	return false
}

func (m *LeaderboardRequest) GetPage() int32 {
	if m != nil {
		return m.Page
	}
	return 0
}

func (m *LeaderboardRequest) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

func (m *LeaderboardRequest) GetGuild() string {
	if m != nil {
		return m.Guild
	}
	return ""
}

func (m *LeaderboardRequest) GetGuildName() string {
	if m != nil {
		return m.GuildName
	}
	return ""
}

type LeaderboardResponse struct {
	Users                []*LeaderboardUser `protobuf:"bytes,1,rep,name=users" json:"users,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *LeaderboardResponse) Reset()         { *m = LeaderboardResponse{} }
func (m *LeaderboardResponse) String() string { return proto.CompactTextString(m) }
func (*LeaderboardResponse) ProtoMessage()    {}
func (*LeaderboardResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_fishy_b39c152d67c83cbd, []int{17}
}
func (m *LeaderboardResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LeaderboardResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LeaderboardResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *LeaderboardResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LeaderboardResponse.Merge(dst, src)
}
func (m *LeaderboardResponse) XXX_Size() int {
	return m.Size()
}
func (m *LeaderboardResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_LeaderboardResponse.DiscardUnknown(m)
}

var xxx_messageInfo_LeaderboardResponse proto.InternalMessageInfo

func (m *LeaderboardResponse) GetUsers() []*LeaderboardUser {
	if m != nil {
		return m.Users
	}
	return nil
}

type LeaderboardUser struct {
	User                 string   `protobuf:"bytes,1,opt,name=user,proto3" json:"user,omitempty"`
	Score                int32    `protobuf:"varint,2,opt,name=score,proto3" json:"score,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LeaderboardUser) Reset()         { *m = LeaderboardUser{} }
func (m *LeaderboardUser) String() string { return proto.CompactTextString(m) }
func (*LeaderboardUser) ProtoMessage()    {}
func (*LeaderboardUser) Descriptor() ([]byte, []int) {
	return fileDescriptor_fishy_b39c152d67c83cbd, []int{18}
}
func (m *LeaderboardUser) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LeaderboardUser) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LeaderboardUser.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *LeaderboardUser) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LeaderboardUser.Merge(dst, src)
}
func (m *LeaderboardUser) XXX_Size() int {
	return m.Size()
}
func (m *LeaderboardUser) XXX_DiscardUnknown() {
	xxx_messageInfo_LeaderboardUser.DiscardUnknown(m)
}

var xxx_messageInfo_LeaderboardUser proto.InternalMessageInfo

func (m *LeaderboardUser) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

func (m *LeaderboardUser) GetScore() int32 {
	if m != nil {
		return m.Score
	}
	return 0
}

type GetBaitInventoryRequest struct {
	User                 string   `protobuf:"bytes,1,opt,name=user,proto3" json:"user,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetBaitInventoryRequest) Reset()         { *m = GetBaitInventoryRequest{} }
func (m *GetBaitInventoryRequest) String() string { return proto.CompactTextString(m) }
func (*GetBaitInventoryRequest) ProtoMessage()    {}
func (*GetBaitInventoryRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_fishy_b39c152d67c83cbd, []int{19}
}
func (m *GetBaitInventoryRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetBaitInventoryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetBaitInventoryRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetBaitInventoryRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetBaitInventoryRequest.Merge(dst, src)
}
func (m *GetBaitInventoryRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetBaitInventoryRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetBaitInventoryRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetBaitInventoryRequest proto.InternalMessageInfo

func (m *GetBaitInventoryRequest) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

type GetBaitInventoryResponse struct {
	MaxBait              int32          `protobuf:"varint,1,opt,name=max_bait,json=maxBait,proto3" json:"max_bait,omitempty"`
	CurrentCount         int32          `protobuf:"varint,2,opt,name=current_count,json=currentCount,proto3" json:"current_count,omitempty"`
	Bait                 *BaitInventory `protobuf:"bytes,3,opt,name=bait" json:"bait,omitempty"`
	CurrentTier          int32          `protobuf:"varint,4,opt,name=current_tier,json=currentTier,proto3" json:"current_tier,omitempty"`
	BaitboxTier          int32          `protobuf:"varint,5,opt,name=baitbox_tier,json=baitboxTier,proto3" json:"baitbox_tier,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *GetBaitInventoryResponse) Reset()         { *m = GetBaitInventoryResponse{} }
func (m *GetBaitInventoryResponse) String() string { return proto.CompactTextString(m) }
func (*GetBaitInventoryResponse) ProtoMessage()    {}
func (*GetBaitInventoryResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_fishy_b39c152d67c83cbd, []int{20}
}
func (m *GetBaitInventoryResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetBaitInventoryResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetBaitInventoryResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetBaitInventoryResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetBaitInventoryResponse.Merge(dst, src)
}
func (m *GetBaitInventoryResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetBaitInventoryResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetBaitInventoryResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetBaitInventoryResponse proto.InternalMessageInfo

func (m *GetBaitInventoryResponse) GetMaxBait() int32 {
	if m != nil {
		return m.MaxBait
	}
	return 0
}

func (m *GetBaitInventoryResponse) GetCurrentCount() int32 {
	if m != nil {
		return m.CurrentCount
	}
	return 0
}

func (m *GetBaitInventoryResponse) GetBait() *BaitInventory {
	if m != nil {
		return m.Bait
	}
	return nil
}

func (m *GetBaitInventoryResponse) GetCurrentTier() int32 {
	if m != nil {
		return m.CurrentTier
	}
	return 0
}

func (m *GetBaitInventoryResponse) GetBaitboxTier() int32 {
	if m != nil {
		return m.BaitboxTier
	}
	return 0
}

type BuyBaitRequest struct {
	User                 string   `protobuf:"bytes,1,opt,name=user,proto3" json:"user,omitempty"`
	Tier                 BaitTier `protobuf:"varint,2,opt,name=tier,proto3,enum=fishyv3.BaitTier" json:"tier,omitempty"`
	Amount               int32    `protobuf:"varint,3,opt,name=amount,proto3" json:"amount,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BuyBaitRequest) Reset()         { *m = BuyBaitRequest{} }
func (m *BuyBaitRequest) String() string { return proto.CompactTextString(m) }
func (*BuyBaitRequest) ProtoMessage()    {}
func (*BuyBaitRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_fishy_b39c152d67c83cbd, []int{21}
}
func (m *BuyBaitRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BuyBaitRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BuyBaitRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *BuyBaitRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BuyBaitRequest.Merge(dst, src)
}
func (m *BuyBaitRequest) XXX_Size() int {
	return m.Size()
}
func (m *BuyBaitRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BuyBaitRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BuyBaitRequest proto.InternalMessageInfo

func (m *BuyBaitRequest) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

func (m *BuyBaitRequest) GetTier() BaitTier {
	if m != nil {
		return m.Tier
	}
	return BaitTier_T1
}

func (m *BuyBaitRequest) GetAmount() int32 {
	if m != nil {
		return m.Amount
	}
	return 0
}

type BuyBaitResponse struct {
	New                  int32    `protobuf:"varint,1,opt,name=new,proto3" json:"new,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BuyBaitResponse) Reset()         { *m = BuyBaitResponse{} }
func (m *BuyBaitResponse) String() string { return proto.CompactTextString(m) }
func (*BuyBaitResponse) ProtoMessage()    {}
func (*BuyBaitResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_fishy_b39c152d67c83cbd, []int{22}
}
func (m *BuyBaitResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BuyBaitResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BuyBaitResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *BuyBaitResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BuyBaitResponse.Merge(dst, src)
}
func (m *BuyBaitResponse) XXX_Size() int {
	return m.Size()
}
func (m *BuyBaitResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BuyBaitResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BuyBaitResponse proto.InternalMessageInfo

func (m *BuyBaitResponse) GetNew() int32 {
	if m != nil {
		return m.New
	}
	return 0
}

type GetBaitTierRequest struct {
	User                 string   `protobuf:"bytes,1,opt,name=user,proto3" json:"user,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetBaitTierRequest) Reset()         { *m = GetBaitTierRequest{} }
func (m *GetBaitTierRequest) String() string { return proto.CompactTextString(m) }
func (*GetBaitTierRequest) ProtoMessage()    {}
func (*GetBaitTierRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_fishy_b39c152d67c83cbd, []int{23}
}
func (m *GetBaitTierRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetBaitTierRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetBaitTierRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetBaitTierRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetBaitTierRequest.Merge(dst, src)
}
func (m *GetBaitTierRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetBaitTierRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetBaitTierRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetBaitTierRequest proto.InternalMessageInfo

func (m *GetBaitTierRequest) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

type GetBaitTierResponse struct {
	Tier                 BaitTier `protobuf:"varint,1,opt,name=tier,proto3,enum=fishyv3.BaitTier" json:"tier,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetBaitTierResponse) Reset()         { *m = GetBaitTierResponse{} }
func (m *GetBaitTierResponse) String() string { return proto.CompactTextString(m) }
func (*GetBaitTierResponse) ProtoMessage()    {}
func (*GetBaitTierResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_fishy_b39c152d67c83cbd, []int{24}
}
func (m *GetBaitTierResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetBaitTierResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetBaitTierResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetBaitTierResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetBaitTierResponse.Merge(dst, src)
}
func (m *GetBaitTierResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetBaitTierResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetBaitTierResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetBaitTierResponse proto.InternalMessageInfo

func (m *GetBaitTierResponse) GetTier() BaitTier {
	if m != nil {
		return m.Tier
	}
	return BaitTier_T1
}

type SetBaitTierRequest struct {
	User                 string   `protobuf:"bytes,1,opt,name=user,proto3" json:"user,omitempty"`
	Tier                 BaitTier `protobuf:"varint,2,opt,name=tier,proto3,enum=fishyv3.BaitTier" json:"tier,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SetBaitTierRequest) Reset()         { *m = SetBaitTierRequest{} }
func (m *SetBaitTierRequest) String() string { return proto.CompactTextString(m) }
func (*SetBaitTierRequest) ProtoMessage()    {}
func (*SetBaitTierRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_fishy_b39c152d67c83cbd, []int{25}
}
func (m *SetBaitTierRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetBaitTierRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetBaitTierRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SetBaitTierRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetBaitTierRequest.Merge(dst, src)
}
func (m *SetBaitTierRequest) XXX_Size() int {
	return m.Size()
}
func (m *SetBaitTierRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SetBaitTierRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SetBaitTierRequest proto.InternalMessageInfo

func (m *SetBaitTierRequest) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

func (m *SetBaitTierRequest) GetTier() BaitTier {
	if m != nil {
		return m.Tier
	}
	return BaitTier_T1
}

type SetBaitTierResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SetBaitTierResponse) Reset()         { *m = SetBaitTierResponse{} }
func (m *SetBaitTierResponse) String() string { return proto.CompactTextString(m) }
func (*SetBaitTierResponse) ProtoMessage()    {}
func (*SetBaitTierResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_fishy_b39c152d67c83cbd, []int{26}
}
func (m *SetBaitTierResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetBaitTierResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetBaitTierResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SetBaitTierResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetBaitTierResponse.Merge(dst, src)
}
func (m *SetBaitTierResponse) XXX_Size() int {
	return m.Size()
}
func (m *SetBaitTierResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SetBaitTierResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SetBaitTierResponse proto.InternalMessageInfo

type SellFishRequest struct {
	User                 string       `protobuf:"bytes,1,opt,name=user,proto3" json:"user,omitempty"`
	Type                 FishCategory `protobuf:"varint,2,opt,name=type,proto3,enum=fishyv3.FishCategory" json:"type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *SellFishRequest) Reset()         { *m = SellFishRequest{} }
func (m *SellFishRequest) String() string { return proto.CompactTextString(m) }
func (*SellFishRequest) ProtoMessage()    {}
func (*SellFishRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_fishy_b39c152d67c83cbd, []int{27}
}
func (m *SellFishRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SellFishRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SellFishRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SellFishRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SellFishRequest.Merge(dst, src)
}
func (m *SellFishRequest) XXX_Size() int {
	return m.Size()
}
func (m *SellFishRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SellFishRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SellFishRequest proto.InternalMessageInfo

func (m *SellFishRequest) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

func (m *SellFishRequest) GetType() FishCategory {
	if m != nil {
		return m.Type
	}
	return FishCategory_FISH
}

type SellFishResponse struct {
	Worth                int32    `protobuf:"varint,1,opt,name=worth,proto3" json:"worth,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SellFishResponse) Reset()         { *m = SellFishResponse{} }
func (m *SellFishResponse) String() string { return proto.CompactTextString(m) }
func (*SellFishResponse) ProtoMessage()    {}
func (*SellFishResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_fishy_b39c152d67c83cbd, []int{28}
}
func (m *SellFishResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SellFishResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SellFishResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SellFishResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SellFishResponse.Merge(dst, src)
}
func (m *SellFishResponse) XXX_Size() int {
	return m.Size()
}
func (m *SellFishResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SellFishResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SellFishResponse proto.InternalMessageInfo

func (m *SellFishResponse) GetWorth() int32 {
	if m != nil {
		return m.Worth
	}
	return 0
}

type CheckTimeRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CheckTimeRequest) Reset()         { *m = CheckTimeRequest{} }
func (m *CheckTimeRequest) String() string { return proto.CompactTextString(m) }
func (*CheckTimeRequest) ProtoMessage()    {}
func (*CheckTimeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_fishy_b39c152d67c83cbd, []int{29}
}
func (m *CheckTimeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckTimeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CheckTimeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CheckTimeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckTimeRequest.Merge(dst, src)
}
func (m *CheckTimeRequest) XXX_Size() int {
	return m.Size()
}
func (m *CheckTimeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckTimeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CheckTimeRequest proto.InternalMessageInfo

type CheckTimeResponse struct {
	Time                 string   `protobuf:"bytes,1,opt,name=time,proto3" json:"time,omitempty"`
	Morning              bool     `protobuf:"varint,2,opt,name=morning,proto3" json:"morning,omitempty"`
	Night                bool     `protobuf:"varint,3,opt,name=night,proto3" json:"night,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CheckTimeResponse) Reset()         { *m = CheckTimeResponse{} }
func (m *CheckTimeResponse) String() string { return proto.CompactTextString(m) }
func (*CheckTimeResponse) ProtoMessage()    {}
func (*CheckTimeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_fishy_b39c152d67c83cbd, []int{30}
}
func (m *CheckTimeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckTimeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CheckTimeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CheckTimeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckTimeResponse.Merge(dst, src)
}
func (m *CheckTimeResponse) XXX_Size() int {
	return m.Size()
}
func (m *CheckTimeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckTimeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CheckTimeResponse proto.InternalMessageInfo

func (m *CheckTimeResponse) GetTime() string {
	if m != nil {
		return m.Time
	}
	return ""
}

func (m *CheckTimeResponse) GetMorning() bool {
	if m != nil {
		return m.Morning
	}
	return false
}

func (m *CheckTimeResponse) GetNight() bool {
	if m != nil {
		return m.Night
	}
	return false
}

type FishRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FishRequest) Reset()         { *m = FishRequest{} }
func (m *FishRequest) String() string { return proto.CompactTextString(m) }
func (*FishRequest) ProtoMessage()    {}
func (*FishRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_fishy_b39c152d67c83cbd, []int{31}
}
func (m *FishRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FishRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FishRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *FishRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FishRequest.Merge(dst, src)
}
func (m *FishRequest) XXX_Size() int {
	return m.Size()
}
func (m *FishRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FishRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FishRequest proto.InternalMessageInfo

type FishResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FishResponse) Reset()         { *m = FishResponse{} }
func (m *FishResponse) String() string { return proto.CompactTextString(m) }
func (*FishResponse) ProtoMessage()    {}
func (*FishResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_fishy_b39c152d67c83cbd, []int{32}
}
func (m *FishResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FishResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FishResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *FishResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FishResponse.Merge(dst, src)
}
func (m *FishResponse) XXX_Size() int {
	return m.Size()
}
func (m *FishResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_FishResponse.DiscardUnknown(m)
}

var xxx_messageInfo_FishResponse proto.InternalMessageInfo

type UserItem struct {
	Current              int32    `protobuf:"varint,1,opt,name=current,proto3" json:"current,omitempty"`
	Owned                []int32  `protobuf:"varint,2,rep,packed,name=owned" json:"owned,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserItem) Reset()         { *m = UserItem{} }
func (m *UserItem) String() string { return proto.CompactTextString(m) }
func (*UserItem) ProtoMessage()    {}
func (*UserItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_fishy_b39c152d67c83cbd, []int{33}
}
func (m *UserItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *UserItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserItem.Merge(dst, src)
}
func (m *UserItem) XXX_Size() int {
	return m.Size()
}
func (m *UserItem) XXX_DiscardUnknown() {
	xxx_messageInfo_UserItem.DiscardUnknown(m)
}

var xxx_messageInfo_UserItem proto.InternalMessageInfo

func (m *UserItem) GetCurrent() int32 {
	if m != nil {
		return m.Current
	}
	return 0
}

func (m *UserItem) GetOwned() []int32 {
	if m != nil {
		return m.Owned
	}
	return nil
}

type UserItems struct {
	Bait                 *UserItem `protobuf:"bytes,1,opt,name=bait" json:"bait,omitempty"`
	Rod                  *UserItem `protobuf:"bytes,2,opt,name=rod" json:"rod,omitempty"`
	Hook                 *UserItem `protobuf:"bytes,3,opt,name=hook" json:"hook,omitempty"`
	Vehicle              *UserItem `protobuf:"bytes,4,opt,name=vehicle" json:"vehicle,omitempty"`
	BaitBox              *UserItem `protobuf:"bytes,5,opt,name=bait_box,json=baitBox" json:"bait_box,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *UserItems) Reset()         { *m = UserItems{} }
func (m *UserItems) String() string { return proto.CompactTextString(m) }
func (*UserItems) ProtoMessage()    {}
func (*UserItems) Descriptor() ([]byte, []int) {
	return fileDescriptor_fishy_b39c152d67c83cbd, []int{34}
}
func (m *UserItems) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserItems) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserItems.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *UserItems) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserItems.Merge(dst, src)
}
func (m *UserItems) XXX_Size() int {
	return m.Size()
}
func (m *UserItems) XXX_DiscardUnknown() {
	xxx_messageInfo_UserItems.DiscardUnknown(m)
}

var xxx_messageInfo_UserItems proto.InternalMessageInfo

func (m *UserItems) GetBait() *UserItem {
	if m != nil {
		return m.Bait
	}
	return nil
}

func (m *UserItems) GetRod() *UserItem {
	if m != nil {
		return m.Rod
	}
	return nil
}

func (m *UserItems) GetHook() *UserItem {
	if m != nil {
		return m.Hook
	}
	return nil
}

func (m *UserItems) GetVehicle() *UserItem {
	if m != nil {
		return m.Vehicle
	}
	return nil
}

func (m *UserItems) GetBaitBox() *UserItem {
	if m != nil {
		return m.BaitBox
	}
	return nil
}

type FishInventory struct {
	Fish                 int32    `protobuf:"varint,1,opt,name=fish,proto3" json:"fish,omitempty"`
	Garbage              int32    `protobuf:"varint,2,opt,name=garbage,proto3" json:"garbage,omitempty"`
	Legendaries          int32    `protobuf:"varint,3,opt,name=legendaries,proto3" json:"legendaries,omitempty"`
	Worth                int32    `protobuf:"varint,4,opt,name=worth,proto3" json:"worth,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FishInventory) Reset()         { *m = FishInventory{} }
func (m *FishInventory) String() string { return proto.CompactTextString(m) }
func (*FishInventory) ProtoMessage()    {}
func (*FishInventory) Descriptor() ([]byte, []int) {
	return fileDescriptor_fishy_b39c152d67c83cbd, []int{35}
}
func (m *FishInventory) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FishInventory) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FishInventory.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *FishInventory) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FishInventory.Merge(dst, src)
}
func (m *FishInventory) XXX_Size() int {
	return m.Size()
}
func (m *FishInventory) XXX_DiscardUnknown() {
	xxx_messageInfo_FishInventory.DiscardUnknown(m)
}

var xxx_messageInfo_FishInventory proto.InternalMessageInfo

func (m *FishInventory) GetFish() int32 {
	if m != nil {
		return m.Fish
	}
	return 0
}

func (m *FishInventory) GetGarbage() int32 {
	if m != nil {
		return m.Garbage
	}
	return 0
}

func (m *FishInventory) GetLegendaries() int32 {
	if m != nil {
		return m.Legendaries
	}
	return 0
}

func (m *FishInventory) GetWorth() int32 {
	if m != nil {
		return m.Worth
	}
	return 0
}

type BaitInventory struct {
	T1                   int32    `protobuf:"varint,1,opt,name=t1,proto3" json:"t1,omitempty"`
	T2                   int32    `protobuf:"varint,2,opt,name=t2,proto3" json:"t2,omitempty"`
	T3                   int32    `protobuf:"varint,3,opt,name=t3,proto3" json:"t3,omitempty"`
	T4                   int32    `protobuf:"varint,4,opt,name=t4,proto3" json:"t4,omitempty"`
	T5                   int32    `protobuf:"varint,5,opt,name=t5,proto3" json:"t5,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BaitInventory) Reset()         { *m = BaitInventory{} }
func (m *BaitInventory) String() string { return proto.CompactTextString(m) }
func (*BaitInventory) ProtoMessage()    {}
func (*BaitInventory) Descriptor() ([]byte, []int) {
	return fileDescriptor_fishy_b39c152d67c83cbd, []int{36}
}
func (m *BaitInventory) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BaitInventory) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BaitInventory.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *BaitInventory) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BaitInventory.Merge(dst, src)
}
func (m *BaitInventory) XXX_Size() int {
	return m.Size()
}
func (m *BaitInventory) XXX_DiscardUnknown() {
	xxx_messageInfo_BaitInventory.DiscardUnknown(m)
}

var xxx_messageInfo_BaitInventory proto.InternalMessageInfo

func (m *BaitInventory) GetT1() int32 {
	if m != nil {
		return m.T1
	}
	return 0
}

func (m *BaitInventory) GetT2() int32 {
	if m != nil {
		return m.T2
	}
	return 0
}

func (m *BaitInventory) GetT3() int32 {
	if m != nil {
		return m.T3
	}
	return 0
}

func (m *BaitInventory) GetT4() int32 {
	if m != nil {
		return m.T4
	}
	return 0
}

func (m *BaitInventory) GetT5() int32 {
	if m != nil {
		return m.T5
	}
	return 0
}

func init() {
	proto.RegisterType((*InventoryRequest)(nil), "fishyv3.InventoryRequest")
	proto.RegisterType((*InventoryResponse)(nil), "fishyv3.InventoryResponse")
	proto.RegisterType((*GetLocationRequest)(nil), "fishyv3.GetLocationRequest")
	proto.RegisterType((*GetLocationResponse)(nil), "fishyv3.GetLocationResponse")
	proto.RegisterType((*SetLocationRequest)(nil), "fishyv3.SetLocationRequest")
	proto.RegisterType((*SetLocationResponse)(nil), "fishyv3.SetLocationResponse")
	proto.RegisterType((*BuyItemRequest)(nil), "fishyv3.BuyItemRequest")
	proto.RegisterType((*BuyItemResponse)(nil), "fishyv3.BuyItemResponse")
	proto.RegisterType((*BlacklistRequest)(nil), "fishyv3.BlacklistRequest")
	proto.RegisterType((*BlacklistResponse)(nil), "fishyv3.BlacklistResponse")
	proto.RegisterType((*UnblacklistRequest)(nil), "fishyv3.UnblacklistRequest")
	proto.RegisterType((*UnblacklistResponse)(nil), "fishyv3.UnblacklistResponse")
	proto.RegisterType((*StartGatherBaitRequest)(nil), "fishyv3.StartGatherBaitRequest")
	proto.RegisterType((*StartGatherBaitResponse)(nil), "fishyv3.StartGatherBaitResponse")
	proto.RegisterType((*CheckGatherBaitRequest)(nil), "fishyv3.CheckGatherBaitRequest")
	proto.RegisterType((*CheckGatherBaitResponse)(nil), "fishyv3.CheckGatherBaitResponse")
	proto.RegisterType((*LeaderboardRequest)(nil), "fishyv3.LeaderboardRequest")
	proto.RegisterType((*LeaderboardResponse)(nil), "fishyv3.LeaderboardResponse")
	proto.RegisterType((*LeaderboardUser)(nil), "fishyv3.LeaderboardUser")
	proto.RegisterType((*GetBaitInventoryRequest)(nil), "fishyv3.GetBaitInventoryRequest")
	proto.RegisterType((*GetBaitInventoryResponse)(nil), "fishyv3.GetBaitInventoryResponse")
	proto.RegisterType((*BuyBaitRequest)(nil), "fishyv3.BuyBaitRequest")
	proto.RegisterType((*BuyBaitResponse)(nil), "fishyv3.BuyBaitResponse")
	proto.RegisterType((*GetBaitTierRequest)(nil), "fishyv3.GetBaitTierRequest")
	proto.RegisterType((*GetBaitTierResponse)(nil), "fishyv3.GetBaitTierResponse")
	proto.RegisterType((*SetBaitTierRequest)(nil), "fishyv3.SetBaitTierRequest")
	proto.RegisterType((*SetBaitTierResponse)(nil), "fishyv3.SetBaitTierResponse")
	proto.RegisterType((*SellFishRequest)(nil), "fishyv3.SellFishRequest")
	proto.RegisterType((*SellFishResponse)(nil), "fishyv3.SellFishResponse")
	proto.RegisterType((*CheckTimeRequest)(nil), "fishyv3.CheckTimeRequest")
	proto.RegisterType((*CheckTimeResponse)(nil), "fishyv3.CheckTimeResponse")
	proto.RegisterType((*FishRequest)(nil), "fishyv3.FishRequest")
	proto.RegisterType((*FishResponse)(nil), "fishyv3.FishResponse")
	proto.RegisterType((*UserItem)(nil), "fishyv3.UserItem")
	proto.RegisterType((*UserItems)(nil), "fishyv3.UserItems")
	proto.RegisterType((*FishInventory)(nil), "fishyv3.FishInventory")
	proto.RegisterType((*BaitInventory)(nil), "fishyv3.BaitInventory")
	proto.RegisterEnum("fishyv3.FishCategory", FishCategory_name, FishCategory_value)
	proto.RegisterEnum("fishyv3.Item", Item_name, Item_value)
	proto.RegisterEnum("fishyv3.Location", Location_name, Location_value)
	proto.RegisterEnum("fishyv3.BaitTier", BaitTier_name, BaitTier_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Fishy service

type FishyClient interface {
	Fishy(ctx context.Context, in *FishRequest, opts ...grpc.CallOption) (*FishResponse, error)
	Inventory(ctx context.Context, in *InventoryRequest, opts ...grpc.CallOption) (*InventoryResponse, error)
	GetLocation(ctx context.Context, in *GetLocationRequest, opts ...grpc.CallOption) (*GetLocationResponse, error)
	SetLocation(ctx context.Context, in *SetLocationRequest, opts ...grpc.CallOption) (*SetLocationResponse, error)
	BuyItem(ctx context.Context, in *BuyItemRequest, opts ...grpc.CallOption) (*BuyItemResponse, error)
	Blacklist(ctx context.Context, in *BlacklistRequest, opts ...grpc.CallOption) (*BlacklistResponse, error)
	Unblacklist(ctx context.Context, in *UnblacklistRequest, opts ...grpc.CallOption) (*UnblacklistResponse, error)
	StartGatherBait(ctx context.Context, in *StartGatherBaitRequest, opts ...grpc.CallOption) (*StartGatherBaitResponse, error)
	CheckGatherBait(ctx context.Context, in *CheckGatherBaitRequest, opts ...grpc.CallOption) (*CheckGatherBaitResponse, error)
	Leaderboard(ctx context.Context, in *LeaderboardRequest, opts ...grpc.CallOption) (*LeaderboardResponse, error)
	CheckTime(ctx context.Context, in *CheckTimeRequest, opts ...grpc.CallOption) (*CheckTimeResponse, error)
	GetBaitInventory(ctx context.Context, in *GetBaitInventoryRequest, opts ...grpc.CallOption) (*GetBaitInventoryResponse, error)
	BuyBait(ctx context.Context, in *BuyBaitRequest, opts ...grpc.CallOption) (*BuyBaitResponse, error)
	GetBaitTier(ctx context.Context, in *GetBaitTierRequest, opts ...grpc.CallOption) (*GetBaitTierResponse, error)
	SetBaitTier(ctx context.Context, in *SetBaitTierRequest, opts ...grpc.CallOption) (*SetBaitTierResponse, error)
	SellFish(ctx context.Context, in *SellFishRequest, opts ...grpc.CallOption) (*SellFishResponse, error)
}

type fishyClient struct {
	cc *grpc.ClientConn
}

func NewFishyClient(cc *grpc.ClientConn) FishyClient {
	return &fishyClient{cc}
}

func (c *fishyClient) Fishy(ctx context.Context, in *FishRequest, opts ...grpc.CallOption) (*FishResponse, error) {
	out := new(FishResponse)
	err := c.cc.Invoke(ctx, "/fishyv3.Fishy/Fishy", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fishyClient) Inventory(ctx context.Context, in *InventoryRequest, opts ...grpc.CallOption) (*InventoryResponse, error) {
	out := new(InventoryResponse)
	err := c.cc.Invoke(ctx, "/fishyv3.Fishy/Inventory", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fishyClient) GetLocation(ctx context.Context, in *GetLocationRequest, opts ...grpc.CallOption) (*GetLocationResponse, error) {
	out := new(GetLocationResponse)
	err := c.cc.Invoke(ctx, "/fishyv3.Fishy/GetLocation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fishyClient) SetLocation(ctx context.Context, in *SetLocationRequest, opts ...grpc.CallOption) (*SetLocationResponse, error) {
	out := new(SetLocationResponse)
	err := c.cc.Invoke(ctx, "/fishyv3.Fishy/SetLocation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fishyClient) BuyItem(ctx context.Context, in *BuyItemRequest, opts ...grpc.CallOption) (*BuyItemResponse, error) {
	out := new(BuyItemResponse)
	err := c.cc.Invoke(ctx, "/fishyv3.Fishy/BuyItem", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fishyClient) Blacklist(ctx context.Context, in *BlacklistRequest, opts ...grpc.CallOption) (*BlacklistResponse, error) {
	out := new(BlacklistResponse)
	err := c.cc.Invoke(ctx, "/fishyv3.Fishy/Blacklist", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fishyClient) Unblacklist(ctx context.Context, in *UnblacklistRequest, opts ...grpc.CallOption) (*UnblacklistResponse, error) {
	out := new(UnblacklistResponse)
	err := c.cc.Invoke(ctx, "/fishyv3.Fishy/Unblacklist", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fishyClient) StartGatherBait(ctx context.Context, in *StartGatherBaitRequest, opts ...grpc.CallOption) (*StartGatherBaitResponse, error) {
	out := new(StartGatherBaitResponse)
	err := c.cc.Invoke(ctx, "/fishyv3.Fishy/StartGatherBait", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fishyClient) CheckGatherBait(ctx context.Context, in *CheckGatherBaitRequest, opts ...grpc.CallOption) (*CheckGatherBaitResponse, error) {
	out := new(CheckGatherBaitResponse)
	err := c.cc.Invoke(ctx, "/fishyv3.Fishy/CheckGatherBait", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fishyClient) Leaderboard(ctx context.Context, in *LeaderboardRequest, opts ...grpc.CallOption) (*LeaderboardResponse, error) {
	out := new(LeaderboardResponse)
	err := c.cc.Invoke(ctx, "/fishyv3.Fishy/Leaderboard", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fishyClient) CheckTime(ctx context.Context, in *CheckTimeRequest, opts ...grpc.CallOption) (*CheckTimeResponse, error) {
	out := new(CheckTimeResponse)
	err := c.cc.Invoke(ctx, "/fishyv3.Fishy/CheckTime", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fishyClient) GetBaitInventory(ctx context.Context, in *GetBaitInventoryRequest, opts ...grpc.CallOption) (*GetBaitInventoryResponse, error) {
	out := new(GetBaitInventoryResponse)
	err := c.cc.Invoke(ctx, "/fishyv3.Fishy/GetBaitInventory", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fishyClient) BuyBait(ctx context.Context, in *BuyBaitRequest, opts ...grpc.CallOption) (*BuyBaitResponse, error) {
	out := new(BuyBaitResponse)
	err := c.cc.Invoke(ctx, "/fishyv3.Fishy/BuyBait", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fishyClient) GetBaitTier(ctx context.Context, in *GetBaitTierRequest, opts ...grpc.CallOption) (*GetBaitTierResponse, error) {
	out := new(GetBaitTierResponse)
	err := c.cc.Invoke(ctx, "/fishyv3.Fishy/GetBaitTier", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fishyClient) SetBaitTier(ctx context.Context, in *SetBaitTierRequest, opts ...grpc.CallOption) (*SetBaitTierResponse, error) {
	out := new(SetBaitTierResponse)
	err := c.cc.Invoke(ctx, "/fishyv3.Fishy/SetBaitTier", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fishyClient) SellFish(ctx context.Context, in *SellFishRequest, opts ...grpc.CallOption) (*SellFishResponse, error) {
	out := new(SellFishResponse)
	err := c.cc.Invoke(ctx, "/fishyv3.Fishy/SellFish", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Fishy service

type FishyServer interface {
	Fishy(context.Context, *FishRequest) (*FishResponse, error)
	Inventory(context.Context, *InventoryRequest) (*InventoryResponse, error)
	GetLocation(context.Context, *GetLocationRequest) (*GetLocationResponse, error)
	SetLocation(context.Context, *SetLocationRequest) (*SetLocationResponse, error)
	BuyItem(context.Context, *BuyItemRequest) (*BuyItemResponse, error)
	Blacklist(context.Context, *BlacklistRequest) (*BlacklistResponse, error)
	Unblacklist(context.Context, *UnblacklistRequest) (*UnblacklistResponse, error)
	StartGatherBait(context.Context, *StartGatherBaitRequest) (*StartGatherBaitResponse, error)
	CheckGatherBait(context.Context, *CheckGatherBaitRequest) (*CheckGatherBaitResponse, error)
	Leaderboard(context.Context, *LeaderboardRequest) (*LeaderboardResponse, error)
	CheckTime(context.Context, *CheckTimeRequest) (*CheckTimeResponse, error)
	GetBaitInventory(context.Context, *GetBaitInventoryRequest) (*GetBaitInventoryResponse, error)
	BuyBait(context.Context, *BuyBaitRequest) (*BuyBaitResponse, error)
	GetBaitTier(context.Context, *GetBaitTierRequest) (*GetBaitTierResponse, error)
	SetBaitTier(context.Context, *SetBaitTierRequest) (*SetBaitTierResponse, error)
	SellFish(context.Context, *SellFishRequest) (*SellFishResponse, error)
}

func RegisterFishyServer(s *grpc.Server, srv FishyServer) {
	s.RegisterService(&_Fishy_serviceDesc, srv)
}

func _Fishy_Fishy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FishRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FishyServer).Fishy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/fishyv3.Fishy/Fishy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FishyServer).Fishy(ctx, req.(*FishRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Fishy_Inventory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InventoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FishyServer).Inventory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/fishyv3.Fishy/Inventory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FishyServer).Inventory(ctx, req.(*InventoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Fishy_GetLocation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLocationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FishyServer).GetLocation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/fishyv3.Fishy/GetLocation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FishyServer).GetLocation(ctx, req.(*GetLocationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Fishy_SetLocation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetLocationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FishyServer).SetLocation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/fishyv3.Fishy/SetLocation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FishyServer).SetLocation(ctx, req.(*SetLocationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Fishy_BuyItem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BuyItemRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FishyServer).BuyItem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/fishyv3.Fishy/BuyItem",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FishyServer).BuyItem(ctx, req.(*BuyItemRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Fishy_Blacklist_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlacklistRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FishyServer).Blacklist(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/fishyv3.Fishy/Blacklist",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FishyServer).Blacklist(ctx, req.(*BlacklistRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Fishy_Unblacklist_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnblacklistRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FishyServer).Unblacklist(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/fishyv3.Fishy/Unblacklist",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FishyServer).Unblacklist(ctx, req.(*UnblacklistRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Fishy_StartGatherBait_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartGatherBaitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FishyServer).StartGatherBait(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/fishyv3.Fishy/StartGatherBait",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FishyServer).StartGatherBait(ctx, req.(*StartGatherBaitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Fishy_CheckGatherBait_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckGatherBaitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FishyServer).CheckGatherBait(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/fishyv3.Fishy/CheckGatherBait",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FishyServer).CheckGatherBait(ctx, req.(*CheckGatherBaitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Fishy_Leaderboard_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LeaderboardRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FishyServer).Leaderboard(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/fishyv3.Fishy/Leaderboard",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FishyServer).Leaderboard(ctx, req.(*LeaderboardRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Fishy_CheckTime_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckTimeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FishyServer).CheckTime(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/fishyv3.Fishy/CheckTime",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FishyServer).CheckTime(ctx, req.(*CheckTimeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Fishy_GetBaitInventory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBaitInventoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FishyServer).GetBaitInventory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/fishyv3.Fishy/GetBaitInventory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FishyServer).GetBaitInventory(ctx, req.(*GetBaitInventoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Fishy_BuyBait_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BuyBaitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FishyServer).BuyBait(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/fishyv3.Fishy/BuyBait",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FishyServer).BuyBait(ctx, req.(*BuyBaitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Fishy_GetBaitTier_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBaitTierRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FishyServer).GetBaitTier(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/fishyv3.Fishy/GetBaitTier",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FishyServer).GetBaitTier(ctx, req.(*GetBaitTierRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Fishy_SetBaitTier_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetBaitTierRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FishyServer).SetBaitTier(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/fishyv3.Fishy/SetBaitTier",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FishyServer).SetBaitTier(ctx, req.(*SetBaitTierRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Fishy_SellFish_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SellFishRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FishyServer).SellFish(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/fishyv3.Fishy/SellFish",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FishyServer).SellFish(ctx, req.(*SellFishRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Fishy_serviceDesc = grpc.ServiceDesc{
	ServiceName: "fishyv3.Fishy",
	HandlerType: (*FishyServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Fishy",
			Handler:    _Fishy_Fishy_Handler,
		},
		{
			MethodName: "Inventory",
			Handler:    _Fishy_Inventory_Handler,
		},
		{
			MethodName: "GetLocation",
			Handler:    _Fishy_GetLocation_Handler,
		},
		{
			MethodName: "SetLocation",
			Handler:    _Fishy_SetLocation_Handler,
		},
		{
			MethodName: "BuyItem",
			Handler:    _Fishy_BuyItem_Handler,
		},
		{
			MethodName: "Blacklist",
			Handler:    _Fishy_Blacklist_Handler,
		},
		{
			MethodName: "Unblacklist",
			Handler:    _Fishy_Unblacklist_Handler,
		},
		{
			MethodName: "StartGatherBait",
			Handler:    _Fishy_StartGatherBait_Handler,
		},
		{
			MethodName: "CheckGatherBait",
			Handler:    _Fishy_CheckGatherBait_Handler,
		},
		{
			MethodName: "Leaderboard",
			Handler:    _Fishy_Leaderboard_Handler,
		},
		{
			MethodName: "CheckTime",
			Handler:    _Fishy_CheckTime_Handler,
		},
		{
			MethodName: "GetBaitInventory",
			Handler:    _Fishy_GetBaitInventory_Handler,
		},
		{
			MethodName: "BuyBait",
			Handler:    _Fishy_BuyBait_Handler,
		},
		{
			MethodName: "GetBaitTier",
			Handler:    _Fishy_GetBaitTier_Handler,
		},
		{
			MethodName: "SetBaitTier",
			Handler:    _Fishy_SetBaitTier_Handler,
		},
		{
			MethodName: "SellFish",
			Handler:    _Fishy_SellFish_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "fishy.proto",
}

func (m *InventoryRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InventoryRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.User) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFishy(dAtA, i, uint64(len(m.User)))
		i += copy(dAtA[i:], m.User)
	}
	return i, nil
}

func (m *InventoryResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InventoryResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Items != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFishy(dAtA, i, uint64(m.Items.Size()))
		n1, err := m.Items.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Fish != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintFishy(dAtA, i, uint64(m.Fish.Size()))
		n2, err := m.Fish.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.MaxFish != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintFishy(dAtA, i, uint64(m.MaxFish))
	}
	if m.MaxBait != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintFishy(dAtA, i, uint64(m.MaxBait))
	}
	if m.UserTier != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintFishy(dAtA, i, uint64(m.UserTier))
	}
	return i, nil
}

func (m *GetLocationRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetLocationRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.User) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFishy(dAtA, i, uint64(len(m.User)))
		i += copy(dAtA[i:], m.User)
	}
	return i, nil
}

func (m *GetLocationResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetLocationResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Location != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFishy(dAtA, i, uint64(m.Location))
	}
	return i, nil
}

func (m *SetLocationRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetLocationRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.User) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFishy(dAtA, i, uint64(len(m.User)))
		i += copy(dAtA[i:], m.User)
	}
	if m.Location != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFishy(dAtA, i, uint64(m.Location))
	}
	return i, nil
}

func (m *SetLocationResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetLocationResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *BuyItemRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuyItemRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Item != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFishy(dAtA, i, uint64(m.Item))
	}
	if m.Tier != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFishy(dAtA, i, uint64(m.Tier))
	}
	return i, nil
}

func (m *BuyItemResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuyItemResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *BlacklistRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlacklistRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.User) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFishy(dAtA, i, uint64(len(m.User)))
		i += copy(dAtA[i:], m.User)
	}
	return i, nil
}

func (m *BlacklistResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlacklistResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *UnblacklistRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnblacklistRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.User) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFishy(dAtA, i, uint64(len(m.User)))
		i += copy(dAtA[i:], m.User)
	}
	return i, nil
}

func (m *UnblacklistResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnblacklistResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *StartGatherBaitRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StartGatherBaitRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.User) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFishy(dAtA, i, uint64(len(m.User)))
		i += copy(dAtA[i:], m.User)
	}
	return i, nil
}

func (m *StartGatherBaitResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StartGatherBaitResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *CheckGatherBaitRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckGatherBaitRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.User) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFishy(dAtA, i, uint64(len(m.User)))
		i += copy(dAtA[i:], m.User)
	}
	return i, nil
}

func (m *CheckGatherBaitResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckGatherBaitResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Remaining != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFishy(dAtA, i, uint64(m.Remaining))
	}
	return i, nil
}

func (m *LeaderboardRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LeaderboardRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Global {
		dAtA[i] = 0x8
		i++
		if m.Global {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Page != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFishy(dAtA, i, uint64(m.Page))
	}
	if len(m.User) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintFishy(dAtA, i, uint64(len(m.User)))
		i += copy(dAtA[i:], m.User)
	}
	if len(m.Guild) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintFishy(dAtA, i, uint64(len(m.Guild)))
		i += copy(dAtA[i:], m.Guild)
	}
	if len(m.GuildName) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintFishy(dAtA, i, uint64(len(m.GuildName)))
		i += copy(dAtA[i:], m.GuildName)
	}
	return i, nil
}

func (m *LeaderboardResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LeaderboardResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Users) > 0 {
		for _, msg := range m.Users {
			dAtA[i] = 0xa
			i++
			i = encodeVarintFishy(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *LeaderboardUser) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LeaderboardUser) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.User) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFishy(dAtA, i, uint64(len(m.User)))
		i += copy(dAtA[i:], m.User)
	}
	if m.Score != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFishy(dAtA, i, uint64(m.Score))
	}
	return i, nil
}

func (m *GetBaitInventoryRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetBaitInventoryRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.User) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFishy(dAtA, i, uint64(len(m.User)))
		i += copy(dAtA[i:], m.User)
	}
	return i, nil
}

func (m *GetBaitInventoryResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetBaitInventoryResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MaxBait != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFishy(dAtA, i, uint64(m.MaxBait))
	}
	if m.CurrentCount != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFishy(dAtA, i, uint64(m.CurrentCount))
	}
	if m.Bait != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintFishy(dAtA, i, uint64(m.Bait.Size()))
		n3, err := m.Bait.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.CurrentTier != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintFishy(dAtA, i, uint64(m.CurrentTier))
	}
	if m.BaitboxTier != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintFishy(dAtA, i, uint64(m.BaitboxTier))
	}
	return i, nil
}

func (m *BuyBaitRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuyBaitRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.User) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFishy(dAtA, i, uint64(len(m.User)))
		i += copy(dAtA[i:], m.User)
	}
	if m.Tier != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFishy(dAtA, i, uint64(m.Tier))
	}
	if m.Amount != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintFishy(dAtA, i, uint64(m.Amount))
	}
	return i, nil
}

func (m *BuyBaitResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuyBaitResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.New != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFishy(dAtA, i, uint64(m.New))
	}
	return i, nil
}

func (m *GetBaitTierRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetBaitTierRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.User) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFishy(dAtA, i, uint64(len(m.User)))
		i += copy(dAtA[i:], m.User)
	}
	return i, nil
}

func (m *GetBaitTierResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetBaitTierResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Tier != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFishy(dAtA, i, uint64(m.Tier))
	}
	return i, nil
}

func (m *SetBaitTierRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetBaitTierRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.User) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFishy(dAtA, i, uint64(len(m.User)))
		i += copy(dAtA[i:], m.User)
	}
	if m.Tier != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFishy(dAtA, i, uint64(m.Tier))
	}
	return i, nil
}

func (m *SetBaitTierResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetBaitTierResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *SellFishRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SellFishRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.User) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFishy(dAtA, i, uint64(len(m.User)))
		i += copy(dAtA[i:], m.User)
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFishy(dAtA, i, uint64(m.Type))
	}
	return i, nil
}

func (m *SellFishResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SellFishResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Worth != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFishy(dAtA, i, uint64(m.Worth))
	}
	return i, nil
}

func (m *CheckTimeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckTimeRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *CheckTimeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckTimeResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Time) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFishy(dAtA, i, uint64(len(m.Time)))
		i += copy(dAtA[i:], m.Time)
	}
	if m.Morning {
		dAtA[i] = 0x10
		i++
		if m.Morning {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Night {
		dAtA[i] = 0x18
		i++
		if m.Night {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *FishRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FishRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *FishResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FishResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *UserItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserItem) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Current != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFishy(dAtA, i, uint64(m.Current))
	}
	if len(m.Owned) > 0 {
		dAtA5 := make([]byte, len(m.Owned)*10)
		var j4 int
		for _, num1 := range m.Owned {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA5[j4] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j4++
			}
			dAtA5[j4] = uint8(num)
			j4++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintFishy(dAtA, i, uint64(j4))
		i += copy(dAtA[i:], dAtA5[:j4])
	}
	return i, nil
}

func (m *UserItems) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserItems) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Bait != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFishy(dAtA, i, uint64(m.Bait.Size()))
		n6, err := m.Bait.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.Rod != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintFishy(dAtA, i, uint64(m.Rod.Size()))
		n7, err := m.Rod.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.Hook != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintFishy(dAtA, i, uint64(m.Hook.Size()))
		n8, err := m.Hook.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.Vehicle != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintFishy(dAtA, i, uint64(m.Vehicle.Size()))
		n9, err := m.Vehicle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.BaitBox != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintFishy(dAtA, i, uint64(m.BaitBox.Size()))
		n10, err := m.BaitBox.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}

func (m *FishInventory) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FishInventory) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Fish != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFishy(dAtA, i, uint64(m.Fish))
	}
	if m.Garbage != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFishy(dAtA, i, uint64(m.Garbage))
	}
	if m.Legendaries != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintFishy(dAtA, i, uint64(m.Legendaries))
	}
	if m.Worth != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintFishy(dAtA, i, uint64(m.Worth))
	}
	return i, nil
}

func (m *BaitInventory) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BaitInventory) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.T1 != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFishy(dAtA, i, uint64(m.T1))
	}
	if m.T2 != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFishy(dAtA, i, uint64(m.T2))
	}
	if m.T3 != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintFishy(dAtA, i, uint64(m.T3))
	}
	if m.T4 != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintFishy(dAtA, i, uint64(m.T4))
	}
	if m.T5 != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintFishy(dAtA, i, uint64(m.T5))
	}
	return i, nil
}

func encodeVarintFishy(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *InventoryRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovFishy(uint64(l))
	}
	return n
}

func (m *InventoryResponse) Size() (n int) {
	var l int
	_ = l
	if m.Items != nil {
		l = m.Items.Size()
		n += 1 + l + sovFishy(uint64(l))
	}
	if m.Fish != nil {
		l = m.Fish.Size()
		n += 1 + l + sovFishy(uint64(l))
	}
	if m.MaxFish != 0 {
		n += 1 + sovFishy(uint64(m.MaxFish))
	}
	if m.MaxBait != 0 {
		n += 1 + sovFishy(uint64(m.MaxBait))
	}
	if m.UserTier != 0 {
		n += 1 + sovFishy(uint64(m.UserTier))
	}
	return n
}

func (m *GetLocationRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovFishy(uint64(l))
	}
	return n
}

func (m *GetLocationResponse) Size() (n int) {
	var l int
	_ = l
	if m.Location != 0 {
		n += 1 + sovFishy(uint64(m.Location))
	}
	return n
}

func (m *SetLocationRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovFishy(uint64(l))
	}
	if m.Location != 0 {
		n += 1 + sovFishy(uint64(m.Location))
	}
	return n
}

func (m *SetLocationResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *BuyItemRequest) Size() (n int) {
	var l int
	_ = l
	if m.Item != 0 {
		n += 1 + sovFishy(uint64(m.Item))
	}
	if m.Tier != 0 {
		n += 1 + sovFishy(uint64(m.Tier))
	}
	return n
}

func (m *BuyItemResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *BlacklistRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovFishy(uint64(l))
	}
	return n
}

func (m *BlacklistResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *UnblacklistRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovFishy(uint64(l))
	}
	return n
}

func (m *UnblacklistResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *StartGatherBaitRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovFishy(uint64(l))
	}
	return n
}

func (m *StartGatherBaitResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *CheckGatherBaitRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovFishy(uint64(l))
	}
	return n
}

func (m *CheckGatherBaitResponse) Size() (n int) {
	var l int
	_ = l
	if m.Remaining != 0 {
		n += 1 + sovFishy(uint64(m.Remaining))
	}
	return n
}

func (m *LeaderboardRequest) Size() (n int) {
	var l int
	_ = l
	if m.Global {
		n += 2
	}
	if m.Page != 0 {
		n += 1 + sovFishy(uint64(m.Page))
	}
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovFishy(uint64(l))
	}
	l = len(m.Guild)
	if l > 0 {
		n += 1 + l + sovFishy(uint64(l))
	}
	l = len(m.GuildName)
	if l > 0 {
		n += 1 + l + sovFishy(uint64(l))
	}
	return n
}

func (m *LeaderboardResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.Users) > 0 {
		for _, e := range m.Users {
			l = e.Size()
			n += 1 + l + sovFishy(uint64(l))
		}
	}
	return n
}

func (m *LeaderboardUser) Size() (n int) {
	var l int
	_ = l
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovFishy(uint64(l))
	}
	if m.Score != 0 {
		n += 1 + sovFishy(uint64(m.Score))
	}
	return n
}

func (m *GetBaitInventoryRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovFishy(uint64(l))
	}
	return n
}

func (m *GetBaitInventoryResponse) Size() (n int) {
	var l int
	_ = l
	if m.MaxBait != 0 {
		n += 1 + sovFishy(uint64(m.MaxBait))
	}
	if m.CurrentCount != 0 {
		n += 1 + sovFishy(uint64(m.CurrentCount))
	}
	if m.Bait != nil {
		l = m.Bait.Size()
		n += 1 + l + sovFishy(uint64(l))
	}
	if m.CurrentTier != 0 {
		n += 1 + sovFishy(uint64(m.CurrentTier))
	}
	if m.BaitboxTier != 0 {
		n += 1 + sovFishy(uint64(m.BaitboxTier))
	}
	return n
}

func (m *BuyBaitRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovFishy(uint64(l))
	}
	if m.Tier != 0 {
		n += 1 + sovFishy(uint64(m.Tier))
	}
	if m.Amount != 0 {
		n += 1 + sovFishy(uint64(m.Amount))
	}
	return n
}

func (m *BuyBaitResponse) Size() (n int) {
	var l int
	_ = l
	if m.New != 0 {
		n += 1 + sovFishy(uint64(m.New))
	}
	return n
}

func (m *GetBaitTierRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovFishy(uint64(l))
	}
	return n
}

func (m *GetBaitTierResponse) Size() (n int) {
	var l int
	_ = l
	if m.Tier != 0 {
		n += 1 + sovFishy(uint64(m.Tier))
	}
	return n
}

func (m *SetBaitTierRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovFishy(uint64(l))
	}
	if m.Tier != 0 {
		n += 1 + sovFishy(uint64(m.Tier))
	}
	return n
}

func (m *SetBaitTierResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *SellFishRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovFishy(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovFishy(uint64(m.Type))
	}
	return n
}

func (m *SellFishResponse) Size() (n int) {
	var l int
	_ = l
	if m.Worth != 0 {
		n += 1 + sovFishy(uint64(m.Worth))
	}
	return n
}

func (m *CheckTimeRequest) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *CheckTimeResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.Time)
	if l > 0 {
		n += 1 + l + sovFishy(uint64(l))
	}
	if m.Morning {
		n += 2
	}
	if m.Night {
		n += 2
	}
	return n
}

func (m *FishRequest) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *FishResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *UserItem) Size() (n int) {
	var l int
	_ = l
	if m.Current != 0 {
		n += 1 + sovFishy(uint64(m.Current))
	}
	if len(m.Owned) > 0 {
		l = 0
		for _, e := range m.Owned {
			l += sovFishy(uint64(e))
		}
		n += 1 + sovFishy(uint64(l)) + l
	}
	return n
}

func (m *UserItems) Size() (n int) {
	var l int
	_ = l
	if m.Bait != nil {
		l = m.Bait.Size()
		n += 1 + l + sovFishy(uint64(l))
	}
	if m.Rod != nil {
		l = m.Rod.Size()
		n += 1 + l + sovFishy(uint64(l))
	}
	if m.Hook != nil {
		l = m.Hook.Size()
		n += 1 + l + sovFishy(uint64(l))
	}
	if m.Vehicle != nil {
		l = m.Vehicle.Size()
		n += 1 + l + sovFishy(uint64(l))
	}
	if m.BaitBox != nil {
		l = m.BaitBox.Size()
		n += 1 + l + sovFishy(uint64(l))
	}
	return n
}

func (m *FishInventory) Size() (n int) {
	var l int
	_ = l
	if m.Fish != 0 {
		n += 1 + sovFishy(uint64(m.Fish))
	}
	if m.Garbage != 0 {
		n += 1 + sovFishy(uint64(m.Garbage))
	}
	if m.Legendaries != 0 {
		n += 1 + sovFishy(uint64(m.Legendaries))
	}
	if m.Worth != 0 {
		n += 1 + sovFishy(uint64(m.Worth))
	}
	return n
}

func (m *BaitInventory) Size() (n int) {
	var l int
	_ = l
	if m.T1 != 0 {
		n += 1 + sovFishy(uint64(m.T1))
	}
	if m.T2 != 0 {
		n += 1 + sovFishy(uint64(m.T2))
	}
	if m.T3 != 0 {
		n += 1 + sovFishy(uint64(m.T3))
	}
	if m.T4 != 0 {
		n += 1 + sovFishy(uint64(m.T4))
	}
	if m.T5 != 0 {
		n += 1 + sovFishy(uint64(m.T5))
	}
	return n
}

func sovFishy(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozFishy(x uint64) (n int) {
	return sovFishy(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *InventoryRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFishy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InventoryRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InventoryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFishy
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFishy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFishy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InventoryResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFishy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InventoryResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InventoryResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFishy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Items == nil {
				m.Items = &UserItems{}
			}
			if err := m.Items.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fish", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFishy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fish == nil {
				m.Fish = &FishInventory{}
			}
			if err := m.Fish.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxFish", wireType)
			}
			m.MaxFish = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxFish |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxBait", wireType)
			}
			m.MaxBait = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxBait |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserTier", wireType)
			}
			m.UserTier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserTier |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFishy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFishy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetLocationRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFishy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetLocationRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetLocationRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFishy
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFishy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFishy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetLocationResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFishy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetLocationResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetLocationResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			m.Location = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Location |= (Location(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFishy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFishy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetLocationRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFishy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetLocationRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetLocationRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFishy
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			m.Location = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Location |= (Location(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFishy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFishy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetLocationResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFishy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetLocationResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetLocationResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFishy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFishy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuyItemRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFishy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuyItemRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuyItemRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
			}
			m.Item = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Item |= (Item(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tier", wireType)
			}
			m.Tier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tier |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFishy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFishy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuyItemResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFishy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuyItemResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuyItemResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFishy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFishy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlacklistRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFishy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlacklistRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlacklistRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFishy
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFishy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFishy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlacklistResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFishy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlacklistResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlacklistResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFishy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFishy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnblacklistRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFishy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnblacklistRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnblacklistRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFishy
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFishy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFishy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnblacklistResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFishy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnblacklistResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnblacklistResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFishy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFishy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StartGatherBaitRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFishy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StartGatherBaitRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StartGatherBaitRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFishy
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFishy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFishy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StartGatherBaitResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFishy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StartGatherBaitResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StartGatherBaitResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFishy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFishy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckGatherBaitRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFishy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckGatherBaitRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckGatherBaitRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFishy
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFishy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFishy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckGatherBaitResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFishy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckGatherBaitResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckGatherBaitResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Remaining", wireType)
			}
			m.Remaining = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Remaining |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFishy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFishy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LeaderboardRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFishy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LeaderboardRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LeaderboardRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Global", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Global = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			m.Page = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Page |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFishy
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Guild", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFishy
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Guild = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFishy
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GuildName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFishy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFishy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LeaderboardResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFishy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LeaderboardResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LeaderboardResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Users", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFishy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Users = append(m.Users, &LeaderboardUser{})
			if err := m.Users[len(m.Users)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFishy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFishy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LeaderboardUser) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFishy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LeaderboardUser: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LeaderboardUser: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFishy
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFishy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFishy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetBaitInventoryRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFishy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetBaitInventoryRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetBaitInventoryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFishy
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFishy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFishy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetBaitInventoryResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFishy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetBaitInventoryResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetBaitInventoryResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxBait", wireType)
			}
			m.MaxBait = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxBait |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentCount", wireType)
			}
			m.CurrentCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bait", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFishy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Bait == nil {
				m.Bait = &BaitInventory{}
			}
			if err := m.Bait.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentTier", wireType)
			}
			m.CurrentTier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentTier |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaitboxTier", wireType)
			}
			m.BaitboxTier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BaitboxTier |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFishy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFishy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuyBaitRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFishy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuyBaitRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuyBaitRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFishy
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tier", wireType)
			}
			m.Tier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tier |= (BaitTier(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			m.Amount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Amount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFishy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFishy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuyBaitResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFishy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuyBaitResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuyBaitResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field New", wireType)
			}
			m.New = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.New |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFishy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFishy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetBaitTierRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFishy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetBaitTierRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetBaitTierRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFishy
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFishy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFishy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetBaitTierResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFishy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetBaitTierResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetBaitTierResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tier", wireType)
			}
			m.Tier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tier |= (BaitTier(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFishy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFishy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetBaitTierRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFishy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetBaitTierRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetBaitTierRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFishy
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tier", wireType)
			}
			m.Tier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tier |= (BaitTier(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFishy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFishy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetBaitTierResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFishy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetBaitTierResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetBaitTierResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFishy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFishy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SellFishRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFishy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SellFishRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SellFishRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFishy
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (FishCategory(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFishy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFishy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SellFishResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFishy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SellFishResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SellFishResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Worth", wireType)
			}
			m.Worth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Worth |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFishy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFishy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckTimeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFishy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckTimeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckTimeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFishy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFishy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckTimeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFishy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckTimeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckTimeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFishy
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Time = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Morning", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Morning = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Night", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Night = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipFishy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFishy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FishRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFishy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FishRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FishRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFishy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFishy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FishResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFishy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FishResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FishResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFishy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFishy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFishy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Current", wireType)
			}
			m.Current = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Current |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFishy
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Owned = append(m.Owned, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFishy
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFishy
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFishy
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Owned = append(m.Owned, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Owned", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFishy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFishy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserItems) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFishy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserItems: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserItems: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bait", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFishy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Bait == nil {
				m.Bait = &UserItem{}
			}
			if err := m.Bait.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rod", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFishy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Rod == nil {
				m.Rod = &UserItem{}
			}
			if err := m.Rod.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hook", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFishy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Hook == nil {
				m.Hook = &UserItem{}
			}
			if err := m.Hook.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vehicle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFishy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Vehicle == nil {
				m.Vehicle = &UserItem{}
			}
			if err := m.Vehicle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaitBox", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFishy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BaitBox == nil {
				m.BaitBox = &UserItem{}
			}
			if err := m.BaitBox.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFishy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFishy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FishInventory) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFishy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FishInventory: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FishInventory: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fish", wireType)
			}
			m.Fish = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fish |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Garbage", wireType)
			}
			m.Garbage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Garbage |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Legendaries", wireType)
			}
			m.Legendaries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Legendaries |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Worth", wireType)
			}
			m.Worth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Worth |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFishy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFishy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BaitInventory) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFishy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BaitInventory: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BaitInventory: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field T1", wireType)
			}
			m.T1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.T1 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field T2", wireType)
			}
			m.T2 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.T2 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field T3", wireType)
			}
			m.T3 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.T3 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field T4", wireType)
			}
			m.T4 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.T4 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field T5", wireType)
			}
			m.T5 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.T5 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFishy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFishy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipFishy(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowFishy
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFishy
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFishy
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthFishy
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowFishy
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipFishy(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthFishy = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowFishy   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("fishy.proto", fileDescriptor_fishy_b39c152d67c83cbd) }

var fileDescriptor_fishy_b39c152d67c83cbd = []byte{
	// 1384 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x57, 0xcd, 0x6e, 0xdb, 0x46,
	0x10, 0x16, 0x29, 0x29, 0xa2, 0x46, 0xb1, 0x4d, 0xaf, 0xed, 0x98, 0x56, 0x52, 0xd7, 0x61, 0xd0,
	0x40, 0x75, 0x13, 0x03, 0x91, 0x93, 0x16, 0x68, 0x9b, 0x02, 0x92, 0xad, 0x28, 0x6e, 0x84, 0xb8,
	0xa0, 0x9c, 0xa4, 0xe9, 0xc5, 0xa0, 0xe4, 0xad, 0x44, 0x44, 0x22, 0x5d, 0x6a, 0x95, 0xd8, 0x8f,
	0xd0, 0x5b, 0xdf, 0xa2, 0x2f, 0xd1, 0x07, 0xe8, 0xa1, 0x87, 0x5e, 0x7b, 0x2b, 0xd2, 0x17, 0x29,
	0x76, 0xb8, 0x24, 0x97, 0x3f, 0x51, 0x7c, 0x12, 0x67, 0xe7, 0xdb, 0x6f, 0x67, 0x66, 0x67, 0x66,
	0x47, 0x50, 0xfb, 0xd9, 0x99, 0x8d, 0x2f, 0xf7, 0xce, 0x7d, 0x8f, 0x79, 0xa4, 0x82, 0xc2, 0xdb,
	0x7d, 0xf3, 0x2e, 0xe8, 0x47, 0xee, 0x5b, 0xea, 0x32, 0xcf, 0xbf, 0xb4, 0xe8, 0x2f, 0x73, 0x3a,
	0x63, 0x84, 0x40, 0x69, 0x3e, 0xa3, 0xbe, 0xa1, 0xec, 0x28, 0x8d, 0xaa, 0x85, 0xdf, 0xe6, 0x1f,
	0x0a, 0xac, 0x4a, 0xc0, 0xd9, 0xb9, 0xe7, 0xce, 0x28, 0x69, 0x40, 0xd9, 0x61, 0x74, 0x3a, 0x43,
	0x68, 0xad, 0x49, 0xf6, 0x04, 0xed, 0xde, 0x8b, 0x19, 0xf5, 0x8f, 0xb8, 0xc6, 0x0a, 0x00, 0x64,
	0x17, 0x4a, 0x5c, 0x67, 0xa8, 0x08, 0xbc, 0x11, 0x01, 0x9f, 0x38, 0xb3, 0x71, 0xcc, 0x8b, 0x18,
	0xb2, 0x05, 0xda, 0xd4, 0xbe, 0x38, 0x45, 0x7c, 0x71, 0x47, 0x69, 0x94, 0xad, 0xca, 0xd4, 0xbe,
	0x78, 0x22, 0xa9, 0x06, 0xb6, 0xc3, 0x8c, 0x52, 0xa4, 0x6a, 0xdb, 0x0e, 0x23, 0x37, 0xa1, 0xca,
	0x2d, 0x3d, 0x65, 0x0e, 0xf5, 0x8d, 0x32, 0xea, 0x34, 0xbe, 0x70, 0xe2, 0x50, 0xdf, 0x6c, 0x00,
	0xe9, 0x52, 0xd6, 0xf3, 0x86, 0x36, 0x73, 0x3c, 0x77, 0x91, 0xa3, 0x87, 0xb0, 0x96, 0x40, 0x0a,
	0x4f, 0xef, 0x83, 0x36, 0x11, 0x6b, 0x08, 0x5f, 0x6e, 0xae, 0x46, 0x3e, 0x44, 0xe0, 0x08, 0x62,
	0xbe, 0x02, 0xd2, 0xbf, 0xd2, 0x79, 0x09, 0x62, 0xf5, 0xe3, 0xc4, 0x1b, 0xb0, 0xd6, 0xcf, 0x9a,
	0x67, 0x76, 0x61, 0xb9, 0x3d, 0xbf, 0xe4, 0x11, 0x0f, 0xcf, 0xba, 0x0d, 0x25, 0x1e, 0x79, 0x61,
	0xec, 0x52, 0xc4, 0x89, 0x18, 0x54, 0x71, 0x73, 0x30, 0x58, 0x2a, 0x06, 0x0b, 0xbf, 0xcd, 0x55,
	0x58, 0x89, 0x88, 0x04, 0xf7, 0x5d, 0xd0, 0xdb, 0x13, 0x7b, 0xf8, 0x66, 0xe2, 0xcc, 0xd8, 0xa2,
	0xc8, 0xad, 0xc1, 0xaa, 0x84, 0x13, 0x9b, 0x1b, 0x40, 0x5e, 0xb8, 0x83, 0xab, 0x6c, 0xdf, 0x80,
	0xb5, 0x04, 0x52, 0x10, 0xdc, 0x83, 0x1b, 0x7d, 0x66, 0xfb, 0xac, 0x6b, 0xb3, 0x31, 0xf5, 0xf9,
	0x4d, 0x2f, 0x22, 0xd9, 0x82, 0xcd, 0x0c, 0x3a, 0x26, 0x3a, 0x18, 0xd3, 0xe1, 0x9b, 0xab, 0x11,
	0x7d, 0x05, 0x9b, 0x19, 0xb4, 0x48, 0x85, 0x5b, 0x50, 0xf5, 0xe9, 0xd4, 0x76, 0x5c, 0xc7, 0x1d,
	0xe1, 0x9e, 0xb2, 0x15, 0x2f, 0x98, 0xbf, 0x2a, 0x40, 0x7a, 0xd4, 0x3e, 0xa3, 0xfe, 0xc0, 0xb3,
	0xfd, 0xb3, 0xf0, 0x8c, 0x1b, 0x70, 0x6d, 0x34, 0xf1, 0x06, 0xf6, 0x04, 0x77, 0x68, 0x96, 0x90,
	0xf8, 0xd9, 0xe7, 0xf6, 0x88, 0x86, 0x77, 0xc0, 0xbf, 0x23, 0x7b, 0x8a, 0x52, 0x9a, 0xac, 0x43,
	0x79, 0x34, 0x77, 0x26, 0x67, 0x98, 0xf5, 0x55, 0x2b, 0x10, 0xc8, 0x27, 0x00, 0xf8, 0x71, 0xea,
	0xda, 0x53, 0x8a, 0x49, 0x5f, 0xb5, 0xaa, 0xb8, 0xf2, 0xdc, 0x9e, 0x52, 0xb3, 0x03, 0x6b, 0x09,
	0x53, 0x84, 0x03, 0x7b, 0x50, 0xe6, 0x9c, 0xbc, 0x6a, 0x8b, 0x8d, 0x5a, 0xd3, 0x88, 0xf3, 0x2d,
	0x06, 0xf3, 0x02, 0xb6, 0x02, 0x98, 0xf9, 0x0d, 0xac, 0xa4, 0x34, 0xb9, 0x99, 0xbc, 0x0e, 0xe5,
	0xd9, 0xd0, 0xf3, 0x43, 0x5f, 0x02, 0xc1, 0xbc, 0x0f, 0x9b, 0x5d, 0xca, 0x78, 0x00, 0xaf, 0xd4,
	0x67, 0xfe, 0x52, 0xc0, 0xc8, 0xe2, 0x85, 0xe1, 0x72, 0xf5, 0x2b, 0xc9, 0xea, 0xbf, 0x03, 0x4b,
	0xc3, 0xb9, 0xef, 0x53, 0x97, 0x9d, 0x0e, 0xbd, 0xb9, 0xcb, 0x84, 0x11, 0xd7, 0xc5, 0xe2, 0x01,
	0x5f, 0xe3, 0x4d, 0x08, 0xf7, 0x16, 0x53, 0x4d, 0x28, 0x79, 0x1a, 0x62, 0xc8, 0x6d, 0x08, 0xf7,
	0x06, 0x1d, 0x25, 0xe8, 0x36, 0x35, 0xb1, 0xc6, 0x9b, 0x0a, 0x87, 0x70, 0xe8, 0xc0, 0xbb, 0x90,
	0x9b, 0x4e, 0x4d, 0xac, 0x61, 0xdf, 0x19, 0x62, 0x5d, 0x7e, 0x24, 0xd9, 0xc8, 0x67, 0x52, 0x21,
	0xca, 0xf5, 0xcf, 0xf7, 0x71, 0x9a, 0xa0, 0x36, 0x79, 0x0e, 0xd9, 0x53, 0x74, 0x2e, 0xe8, 0x8a,
	0x42, 0x32, 0xef, 0x60, 0xcd, 0x26, 0x72, 0x54, 0x87, 0xa2, 0x4b, 0xdf, 0x89, 0x20, 0xf1, 0x4f,
	0xd1, 0x01, 0x23, 0xc6, 0x05, 0x57, 0xf0, 0x2d, 0x76, 0xc0, 0x18, 0x29, 0x28, 0x43, 0x23, 0x95,
	0x85, 0x46, 0x9a, 0xc7, 0xd8, 0xf9, 0xae, 0x70, 0xce, 0x15, 0xbd, 0x16, 0x1d, 0x2f, 0x6d, 0x8e,
	0xf9, 0x03, 0xac, 0xf4, 0xe9, 0x64, 0xc2, 0x5f, 0x85, 0x45, 0x87, 0x7c, 0x0e, 0x25, 0x76, 0x79,
	0x4e, 0xc5, 0x21, 0x1b, 0x89, 0x77, 0xe7, 0xc0, 0x66, 0x74, 0x84, 0x37, 0xce, 0x21, 0x66, 0x03,
	0xf4, 0x98, 0x51, 0x38, 0xbd, 0x0e, 0xe5, 0x77, 0x9e, 0xcf, 0xc6, 0x22, 0x92, 0x81, 0x60, 0x12,
	0xd0, 0xb1, 0x39, 0x9c, 0x38, 0x53, 0x2a, 0x0e, 0x37, 0x5f, 0xc1, 0xaa, 0xb4, 0x26, 0xb6, 0x63,
	0x87, 0x9d, 0xd2, 0xd0, 0x22, 0xfe, 0x4d, 0x0c, 0xa8, 0x4c, 0x3d, 0x1f, 0x9b, 0x87, 0x8a, 0xad,
	0x20, 0x14, 0xf9, 0x61, 0xae, 0x33, 0x1a, 0x07, 0xd7, 0xab, 0x59, 0x81, 0x60, 0x2e, 0x41, 0x4d,
	0x72, 0xd2, 0x5c, 0x86, 0xeb, 0xb2, 0x85, 0xe6, 0xd7, 0xa0, 0x85, 0x8f, 0x2d, 0xa7, 0x16, 0xf9,
	0x19, 0x96, 0x87, 0x10, 0x39, 0xb5, 0xf7, 0xce, 0xa5, 0x67, 0x86, 0xba, 0x53, 0xe4, 0x7e, 0xa0,
	0x60, 0xfe, 0xa3, 0x40, 0x35, 0x7a, 0xa9, 0xf9, 0x7d, 0x44, 0x95, 0x55, 0x93, 0xee, 0x23, 0x44,
	0x88, 0xc2, 0xb8, 0x03, 0x45, 0xdf, 0x3b, 0x13, 0x0f, 0x79, 0x0e, 0x8a, 0x6b, 0x39, 0xd7, 0xd8,
	0xf3, 0xde, 0x88, 0x4a, 0xcb, 0xe3, 0xe2, 0x6a, 0xf2, 0x05, 0x54, 0xde, 0xd2, 0xb1, 0x33, 0x9c,
	0x50, 0xac, 0xaf, 0x5c, 0x64, 0x88, 0x20, 0xf7, 0x40, 0xe3, 0x06, 0x9c, 0x0e, 0xbc, 0x0b, 0x2c,
	0xb5, 0x7c, 0x34, 0x87, 0xb4, 0xbd, 0x0b, 0x73, 0x0e, 0x4b, 0x89, 0xd9, 0x82, 0xdf, 0x05, 0x4e,
	0x14, 0x41, 0x64, 0x82, 0x49, 0xc3, 0x80, 0xca, 0xc8, 0xf6, 0x07, 0x71, 0x03, 0x0e, 0x45, 0xb2,
	0x03, 0xb5, 0x09, 0x1d, 0x51, 0xf7, 0xcc, 0xf6, 0x1d, 0x3a, 0x13, 0x05, 0x27, 0x2f, 0xc5, 0xa9,
	0x51, 0x92, 0x53, 0xe3, 0x14, 0x96, 0x12, 0xdd, 0x84, 0x2c, 0x83, 0xca, 0x1e, 0x88, 0x43, 0x55,
	0xf6, 0x00, 0xe5, 0xa6, 0x38, 0x4d, 0x65, 0x4d, 0x94, 0xf7, 0x05, 0xbf, 0xca, 0xf6, 0x51, 0x7e,
	0x28, 0x38, 0x55, 0xf6, 0x10, 0xe5, 0x47, 0xa2, 0xb5, 0xa8, 0xec, 0xd1, 0xee, 0xe3, 0xe0, 0xfe,
	0xc3, 0xdc, 0x25, 0x1a, 0x94, 0x9e, 0x1c, 0xf5, 0x9f, 0xea, 0x05, 0xb2, 0x04, 0xd5, 0x5e, 0xa7,
	0xdb, 0x79, 0x7e, 0xd8, 0xb2, 0x5e, 0xeb, 0x0a, 0xa9, 0x41, 0xa5, 0xdb, 0xb2, 0xda, 0xad, 0x6e,
	0x47, 0x57, 0x49, 0x05, 0x8a, 0xad, 0x5e, 0x4f, 0x2f, 0xee, 0x3e, 0x86, 0x12, 0xa6, 0x8a, 0x06,
	0xa5, 0x76, 0xeb, 0xe8, 0x44, 0x2f, 0x70, 0x95, 0x75, 0x7c, 0xa8, 0x2b, 0x7c, 0xe9, 0xe9, 0xf1,
	0xf1, 0x33, 0x5d, 0xe5, 0x5b, 0x5f, 0x76, 0x9e, 0x1e, 0x1d, 0xf4, 0x3a, 0x7a, 0x91, 0x0b, 0x1c,
	0xd9, 0x3e, 0xfe, 0x51, 0x2f, 0xed, 0xee, 0x82, 0x16, 0xce, 0x1e, 0x1c, 0xdf, 0x6b, 0x3d, 0xeb,
	0xe8, 0x05, 0x52, 0x85, 0xb2, 0x75, 0xf4, 0xb2, 0x63, 0xe9, 0x0a, 0xff, 0x3c, 0x3e, 0xe8, 0xb4,
	0x9e, 0xeb, 0xea, 0x6e, 0x13, 0xb4, 0xb0, 0x6a, 0xc9, 0x35, 0x50, 0x4f, 0x1e, 0xe8, 0x05, 0xfc,
	0x6d, 0xea, 0x0a, 0xfe, 0xee, 0xeb, 0x2a, 0xfe, 0x3e, 0xd4, 0x8b, 0xf8, 0xfb, 0x48, 0x2f, 0x35,
	0x7f, 0xaf, 0x42, 0x99, 0xbb, 0x77, 0x49, 0xbe, 0x0c, 0x3f, 0xd6, 0x13, 0x35, 0x2b, 0xca, 0xa0,
	0xbe, 0x91, 0x5a, 0x15, 0xd5, 0x50, 0x20, 0x87, 0x50, 0x8d, 0x83, 0xbf, 0x15, 0x8f, 0x3d, 0xa9,
	0xc7, 0xa7, 0x5e, 0xcf, 0x53, 0x45, 0x2c, 0xdf, 0x43, 0x4d, 0x9a, 0x02, 0xc9, 0xcd, 0x08, 0x9c,
	0x9d, 0x22, 0xeb, 0xb7, 0xf2, 0x95, 0x32, 0x57, 0x3f, 0x97, 0xab, 0xbf, 0x88, 0xab, 0x9f, 0xcb,
	0xf5, 0x1d, 0x54, 0xc4, 0x78, 0x46, 0x36, 0xe3, 0x86, 0x99, 0x98, 0xfc, 0xea, 0x46, 0x56, 0x21,
	0x47, 0x27, 0x9a, 0xd1, 0xa4, 0xe8, 0xa4, 0xe7, 0x3b, 0x29, 0x3a, 0xd9, 0x91, 0x0e, 0x3d, 0x92,
	0x46, 0x35, 0xc9, 0xa3, 0xec, 0xa8, 0x27, 0x79, 0x94, 0x37, 0xdd, 0x15, 0xc8, 0x4b, 0x58, 0x49,
	0x4d, 0x6c, 0xe4, 0xd3, 0x38, 0x08, 0xb9, 0x93, 0x5f, 0x7d, 0xe7, 0xc3, 0x00, 0x99, 0x37, 0x35,
	0xc0, 0x49, 0xbc, 0xf9, 0x83, 0xa0, 0xc4, 0xfb, 0x81, 0xd9, 0x2f, 0xf0, 0x5d, 0x1a, 0x86, 0x24,
	0xdf, 0xb3, 0x43, 0x9f, 0xe4, 0x7b, 0xce, 0x18, 0x16, 0xdc, 0x46, 0xf4, 0x66, 0x48, 0xb7, 0x91,
	0x7e, 0x5b, 0xa4, 0xdb, 0xc8, 0x3c, 0x31, 0x66, 0x81, 0xbc, 0x06, 0x3d, 0x3d, 0x31, 0x91, 0x1d,
	0x39, 0x27, 0xf3, 0x86, 0xaf, 0xfa, 0xed, 0x05, 0x88, 0x54, 0xba, 0x61, 0xf0, 0x12, 0xe9, 0x26,
	0x07, 0xcd, 0xc8, 0x2a, 0x52, 0x65, 0x14, 0x75, 0x81, 0x9b, 0xe9, 0x33, 0xa5, 0x11, 0x21, 0x59,
	0x46, 0x99, 0xe7, 0x3e, 0x2c, 0xa3, 0x1c, 0xae, 0xfe, 0x22, 0xae, 0x7e, 0x2e, 0x57, 0x0b, 0xb4,
	0xf0, 0xa9, 0x27, 0x86, 0x84, 0x4d, 0xcc, 0x13, 0xf5, 0xad, 0x1c, 0x4d, 0x48, 0xd1, 0x5e, 0xff,
	0xf3, 0xfd, 0xb6, 0xf2, 0xf7, 0xfb, 0x6d, 0xe5, 0xdf, 0xf7, 0xdb, 0xca, 0x6f, 0xff, 0x6d, 0x17,
	0x7e, 0x52, 0xcf, 0x07, 0x83, 0x6b, 0xf8, 0xf7, 0x7a, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff,
	0x84, 0xe8, 0xa4, 0x31, 0x6d, 0x0f, 0x00, 0x00,
}
